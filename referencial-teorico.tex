\chapter{Referencial Teórico}
Este capítulo apresenta os conceitos de entropia, métricas socias e métricas de processo e indicadores de qualidade.

\section{Entropia de mudança}
A entropia de \citeonline{Shannon:2001:MTC:584091.584093} é uma medida para mensurar a incerteza associada a uma variável que quantifica uma informação contida em uma mensagem produzida por um emissor de dados. É utilizada para determinar a quantidade de bits necessários para identificar unicamente um distribuidor de dados, assim quanto maior a entropia maior a incerteza para identifica-lo. A partir disso foi criado a entropia de mudança com o objetivo de calcular o quanto um código está mudando durante um determinado período de tempo. 

A entropia de mudança introduzida por \citeonline{Hassan:2009:PFU:1555001.1555024} considera que o software é o emissor de dados e as modificações realizadas são os dados a serem considerados. É uma medida para mensurar a quantidade de mudanças que ocorreram em um determinado espaço de tempo em um arquivo de um projeto, as mudança consideradas podem ser obtidas a partir da quantidade de linhas modificadas em um intervalo de tempo ou utilizando número de commits. Hassan também mostrou que alta entropia está relacionada a maior tendência do projeto apresentar falhas.

A entropia de mudança é definida como:

\begin{equation}
H(S) = {\sum\limits_{n=1} }\frac{chg(f_i)}{chg(S)}log_2(\frac{chg(f_i)}{chg(S)})
\end{equation}

\subsection{Trabalhos Relacionados}
No trabalho de \citeonline{Hassan:2009:PFU:1555001.1555024} foi introduzido o conceito de entropia de mudança do software e foi feito um modelo básico de mudança de código(Basic Code Change Model - BCC) para mensurar a complexidade de um processo de mudança.

No modelo básico de mudança de código é utilizado arquivos como unidade de código para mensurar a complexidade de código, o intervalo de tempo para o cálculo da entropia é fixo e é considerado que os arquivos do projeto sejam sempre os mesmos. Para eliminar a limitação do tempo e a limitação alteração no número arquivos é utilizado o modelo extendido de mudança de código(ECC).

No ECC o histórico de mudanças é dividido em períodos de tamanhos iguais. Essa divisão pode ser feita com base em diferentes critérios: com base no tempo, no número de modificações ou em períodos onde ocorrem mais modificações(burst based period). A entropia será calculada com base no número de modificações que ocorreram no período definido.

\citeonline{Hassan:2009:PFU:1555001.1555024} aplicou o modelo ECC para 6 projetos: NetBSD, FreeBSD, OpenBSD, Postgres, KDE e KOffice. Nesse estudo foi comparado modelos de predição de defeitos baseados na entropia, modelo baseados em defeitos anteriores e modelo baseado em modificações anteriores.

Os resultados indicam que modelos baseados na métrica de entropia tem o desempenho igual ou superior aos modelos baseados em modificações anteiores e baseados em defeitos anteiores.

A pesquisa de \citeonline{Canfora2014} relaciona a entropia de mudança com características do software e atividades de desenvolvimento. As características analisadas foram: refatoração, número de commiters, padrões de projetos e nome de tópicos no projeto. Na pesquisa foram analisados projetos nos sistemas ArgoUML, Eclipse-JDT, Mozilla e Samba em um período de cerca de 10 anos e foi mostrado como esses fatores se relacionam com a entropia, que por consequencia impacta a qualidade do software.

Nesse estudo, o método para extração de dados é dividido em 6 passos: extração das métricas de mudança do sistema de controle de versão, cálculo da entropia de mudança, identificação das mudanças relacionadas a refatoração, contar número de autores que contribuem para o projeto, identificação dos padrões de projetos e por último é necessário identificar os tópicos que são descritos na mensagem de cada commit. 

Após a extração dos dados é feito a análise desses dados para responder cinco questões de pesquisa: Como a refatoração afeta a entropia de mudança(RQ1), como a mudança de entropia está relacionada ao número de contribuidores de um arquivo(RQ2), como a entropia de mudança varia entre classes que participam ou não dos padrões de projetos(RQ3), como a mudança de entropia se relaciona com os tópicos descritos na mensagem do commit(RQ4) e como todos os fatores descritos nas questões de pesquisa anteriores se relacionam com a entropia de mudança(RQ5). 

Para responder a RQ1, é feito a comparação do valor da entropia antes e depois da refatoração. 

Para RQ2 é utilizado boxplots onde é contado o número cumulativo de desenvolvedores que, até aquela mudança, tenham alterado o arquivo após isso é feita a correlação entre a mudança de entropia observada em um arquivo para cada conjunto de mudança e o número de desenvolvedores que modificaram o arquivo até aquele conjunto de mudança, considerando todos os arquivos para todos os conjuntos de mudança.

Na RQ3 é utilizado teste de Mann-Whitney e Cliff's delta para comparar mudanças de entropia para classes que participam ou não de padrões de projeto. Então é feito o teste de Kruskal-Wallis para checar se diferentes tipos de padrões de projeto exibem valores diferentes de entropia.

Na RQ4, após classificar o conjunto de mudanças de acordo com os tópicos da mensagem de commit, é comparado a entropia de mudança pertencente a diferentes tópicos utilizando o teste de Kruskal-Wallis.

A RQ5 tem como objetivo analizar a relação entre os diferentes fatores descritos nas questões de pesquisa anteriores e como esses fatores afetam a entropia de mudança. Para responder essa questão foi utilizado Kruskal-Wallis e ANOVA. 

Os resultados de Canfora indicam que: a entropia de mudança diminui de forma significante após uma atividade de refatoração(RQ1), o valor da entropia é mais alto para arquivos com maior número de contribuidores(RQ2), classes que participam de diferentes padrões de projetos exibem valores diferentes de entropia(RQ3), mudanças classificadas em diferentes tópicos exibem valores de entropia diferentes(RQ4) e há maior relação entre o valor da entropia, tópicos de mudança e número de desenvolvedores que modificam um arquivo(RQ5). 

\section{Métricas}
\subsection{Métricas de autoria}
Esta seção apresenta métricas para calculadas a partir das atividades dos usuário em cada projeto.

\subsubsection{Authorship}
Authorship é uma medida para mensurar o quanto um desenvolvedor contribuiu para um determinado módulo de software.

Essa medida pode ser obtida de várias formas: contando número de arquivos que o desenvolvedor modificou, número de commits e outra possibilidade é contar número de linhas modificadas pelo contribuidor, também chamada de code churn\cite{Munson:1998:CCM:850947.853326}.

Na pesquisa realizada por \citeonline{Rahman2011} o authorship é calculado utilizando o número de linhas modificadas no código pelo desenvolvedor dividido pelo número total de linhas do arquivo, e o autor com a maior contribuição é denomidado ownership. Também é definido implicated code, que é o código modificado quando é corrigido um determinado erro no módulo de software. O trabalho de Rahman investiga a relação entre ownership, authorship e experience com implicated code. Para cada linha de código modificado é utilizado o comando blame para identificar o autor responsável por essa mudança. O resultado fornece evidências indicando que implicated code tende a ser mais frequentemente gerado por poucos autores, vários fragmentos de códigos modificados tem apenas um único autor.

\subsubsection{Ownership}
No trabalho de Greiler e Kim Herzig\cite{Greiler} o Ownership é medido considerando número de contribuidores de um arquivo e também é verificado se existe um contribuidor principal, nesse caso a medida foi calculada com base no número de commits do autor em relação ao total de commits para aquele componente.

No artigo de \citeonline{Foucault2015} os contribuidores são classificados como owner, minor e major. Owner é o contribuidor com maior valor de contribuição, minor o desenvolvedor que contribuiu com menos de 5\% e major contribuiu com mais de 5\%.

A métrica social ownership será usada para se referir ao authorship do desenvolvedor que mais contribuiu com o projeto. 

\subsubsection{Experiência}
A experience é a medida para calcular o nível de experiência do contribuidor, essa medida é computada analisando o número de linhas\cite{Rahman2011} deltas comitadas pelo contribuidor em determinado espaço de tempo.

Na pesquisa de Rahman\citeonline{Rahman2011} a experiencia é dividida em dois tipos: a experience especializada e experience geral. A experience especializada é medida considerando o quanto um indivíduo contribui em um determinado arquivo e a experiência geral é medida conseiderando um projeto inteiro.

\subsection{Métricas Sociais}
\subsubsection{Quantidade de mensagens trocadas}

\subsection{Métricas de processo}
Esta seção apresenta as métricas extraídas utilizando a ferramenta Change Metrics desenvolvida por Maurício Aniche.
\subsubsection{Quantidade de autores}
Esta métrica é utilizada para contar a quantidade de autores diferentes que contribuem com o projeto.
\subsubsection{Quantidade de commits}
A quantidade de commits representa o nível de atividade do projeto em termos de número de commits feitos. È calculado o número de commits do projeto em um certo perído de tempo. 
\subsubsection{Quantidade de defeitos}
A quantidade de defeitos será calculado com o número de issues do projeto que foram criadas em uma determinada data. Essa data é obtida a partir do GHTorrent no campo created\_at.
\subsubsection{Idade do repositório}
A métrica idade do repositório representa o tempo de existência do projeto. O cálculo é utilizado medindo a diferença de tempo entre o primeiro e último commit.